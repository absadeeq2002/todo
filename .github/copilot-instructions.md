<!-- .github/copilot-instructions.md generated by AI assistant -->
# Copilot / Agent Quick-Start for this repo

This file gives focused, actionable guidance so an AI coding agent can be immediately productive in this repository.

**Big Picture**
- **Architecture**: A tiny microservice-style example: multiple small Flask services live in `services/` and read JSON files from `database/`. An orchestrating `run.py` and a `docker-compose.yml` wire services together for local/dev runs.
- **Primary components**: `services/users.py`, `services/todo.py`, `services/auth.py`, `services/log_processor.py`, `run.py`, `docker-compose.yml`, `Dockerfile`, and the JSON stores in `database/`.

**How services communicate / data flow**
- Services are simple HTTP APIs (Flask). Example endpoints: `GET /users` served by `services/users.py`, `GET /todos` by `services/todo.py`, and `POST /login` / `POST /register` by `services/auth.py`.
- Data persistence is file-based JSON under `database/` (e.g., `database/users.json`, `database/todo.json`). No DB server is used.

**Developer workflows & important commands**
- Run all services locally via Docker Compose: `docker-compose up --build` (Windows PowerShell: run from project root).
- Run a single service for quick debugging: `python services/users.py` or `python services/todo.py` (requires `Flask` from `requirements.txt`).
- Virtualenv (Windows PowerShell):
  - `python -m venv venv`
  - `.\\venv\\Scripts\\Activate.ps1`
  - `pip install -r requirements.txt`
- `run.py` is a boot manager that reads `dependencies.ini` (format: `service_auth=localhost:5001`) and attempts to start missing services. It uses `lsof` to check ports (may be unavailable on Windows/inside containers).

**Project-specific conventions / gotchas (important!)**
- Services are minimal Flask apps each exposing a small set of endpoints and expecting an environment `PORT` variable.
- Data is mutated directly by `auth.py` via JSON file write (`save_users`) — be careful when editing sample data.
- Docker Compose contains inconsistencies worth noting:
  - `auth` service in `docker-compose.yml` runs `python services/users.py` (this likely should be `services/auth.py`). Double-check when changing service behavior.
  - Port mappings use container-side ports sometimes different from `PORT` env values (e.g. `ports: "5001:5002"` while `PORT=5002`). Agents should verify actual container command/port.
- `run.py` expects `dependencies.ini`; if missing, it exits. For local iterative work, prefer launching target Flask files directly.

**Files to inspect when changing behavior**
- HTTP endpoints & logic: `services/*.py` (users, todo, auth)
- Service orchestration: `run.py` and `docker-compose.yml`
- Build/runtime image: `Dockerfile`
- Data seeds: `database/*.json`
- Python deps: `requirements.txt`

**Editing and testing guidance for agents**
- When adding endpoints: follow existing pattern — create route in `services/<name>.py`, read/write `database/*.json` with `json.load`/`json.dump` and keep behavior consistent with other services.
- For integration checks: run the service locally (not via `run.py`) and curl the endpoint, e.g. `curl http://localhost:5002/users`.
- If you change `docker-compose.yml`, ensure `command` and `environment: - PORT` align with the Python script's `if __name__ == '__main__'` port.

**Examples taken from this repo**
- `services/users.py` — serves `GET /users` and reads `database/users.json`.
- `services/todo.py` — serves `GET /todos` and reads `database/todo.json`.
- `services/auth.py` — exposes `POST /login` and `POST /register`, and writes back to `database/users.json`.
- `run.py` — reads `dependencies.ini`, checks ports with `lsof`, and attempts to start services by running `services/<name>/app.py` (note: current repo structure runs `services/*.py` directly; `run.py` references `services/<name>/app.py` which may not exist).

If anything here is unclear or you'd like the agent to incorporate additional conventions (tests, CI, or different run profiles), tell me which areas to expand and I'll iterate.
